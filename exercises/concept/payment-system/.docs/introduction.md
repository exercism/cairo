# Introduction

A **Trait** in Cairo defines a collection of methods that different types must implement. It specifies what methods must exist, but not how they should be implemented. Different types can then provide their own unique behavior for the methods defined by the trait.

```rust
#[derive(Drop)]
struct Counter {
    value: u32,
}

trait CounterTrait {
    fn increment(ref self: Counter, by: u32);
    fn get_value(self: @Counter) -> u32;
}
```

Methods are similar to functions: we declare them with the `fn` keyword and a name, they can have parameters and a return value, and they contain some code that's run when the method is called from somewhere else. Unlike functions, methods are defined within the context of a struct or an enum, and their first parameter is always `self`, which represents the instance of the type the method is being called on.

We implement a trait and its methods using the `impl` keyword like in the example below:

```rust
impl CounterTraitImpl of CounterTrait {
    fn increment(ref self: Counter, by: u32) {
        self.value += by;
    }

    fn get_value(self: @Counter) -> u32 {
        *self.value
    }
}
```

We can also use the `[generate_trait]` attribute above the `impl` block to completely omit the need to explicitly define the trait.

```rust
#[generate_trait]
impl ExampleTraitImpl of ExampleTrait { // The `ExampleTrait` trait is auto-generated by the compiler
    fn do_something(a: felt252, b: felt252) -> felt252 {
        a + b
    }
}
```

In addition to regular methods, traits can also define something like static functions that do not take `self` as a parameter. These functions are called directly from the trait itself rather than from an instance of the type.

```rust
#[generate_trait]
impl CreatorTraitImpl of CreatorTrait {
    fn new(value: u32) -> Counter {
        Counter { value }
    }
}
```

This method can be invoked like this:

```rust
let counter = CreatorTrait::new(0);
```

This kind of method can be useful for operations that don't need to depend on any particular instance of a type.
